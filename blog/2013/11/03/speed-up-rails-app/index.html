
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Way to speed up rails apps - BenCao Blog</title>
	<meta name="author" content="Ben Cao">

	
	<meta name="description" content="Way to Speed Up Rails Apps Performance is always a bottleneck for rails apps.
Why?
Maybe calling a method in other active records is way too easy, &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="BenCao Blog" type="application/atom+xml">
	
	<link rel="canonical" href="http://blog.bencao.it/blog/2013/11/03/speed-up-rails-app/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- Deck.js -->
<!-- Style theme. Located in /themes/style/ or create your own. -->
<link rel="stylesheet" href="/stylesheets/deck.js/themes/style/.css" type='text/css'>
<!-- Transition theme. Located in /themes/transition/ or create your own. -->
<link rel="stylesheet" href="/stylesheets/deck.js/themes/transition/.css" type='text/css'>

<script type="text/javascript" src="/javascripts/modernizr-2.0.js"></script>

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("") + "?s=160' alt='Profile Picture' style='width: 160px;'");
	</script>
</div>
<h1><a href="/">BenCao Blog</a></h1>
<p class="subtitle">tech life</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/slides">Slides</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		
		
		
		<a class="github" href="https://github.com/bencao" title="GitHub">GitHub</a>
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">Way to Speed Up Rails Apps</h1>
	<div class="entry-content" itemprop="articleBody"><p>Performance is always a bottleneck for rails apps.
Why?
Maybe calling a method in other active records is way too easy, so we&#8217;re apt to call more, and delegate more.
But call and delegate is not free, it&#8217;s db operations under the hood, which are expensive.
Besides that, it&#8217;s very common that we bind many &#8216;before&#8217; and &#8216;after&#8217; callbacks on active record, which results in more and more CPU time during load.
To sum up, as rails developers, we&#8217;re very likely to encounter performance issue, so it&#8217;s better to equip ourselves with some swiss army knife.</p>

<h2>Find out the problem</h2>

<p>Before start optimizing something, the first step is to find out what the problem is.</p>

<p>Ok, it&#8217;s not a rocket science since we have ruby prof gem in hand.</p>

<h3>Ruby Prof</h3>

<p>Some background is needed here - you&#8217;d better go <a href="https://github.com/ruby-prof/ruby-prof">ruby prof website</a> to know more.
With the help of ruby prof, you can easily wrap some pieces of your code, then trigger one run, and you will see the performance data for this piece of code including:
- time percentage spent by each sub function call
- the call counts for each function</p>

<p>I recommend using the &#8220;RubyProf::GraphHtmlPrinter - Creates a call graph report in HTML (separate files per thread)&#8221; to print result to a html page.</p>

<h2>Cache</h2>

<p>We can see from ruby prof result that some methods were consuming more resource that we&#8217;d thought.
One possibility is it&#8217;s called too many times.</p>

<p>If one method is called many times and for each time it&#8217;s called, it returns the same result, it&#8217;s the scenario that we can cache the return of method.
Before doing cache, please remember cache should not break the system, and should have the minimal intrusiveness as possible.</p>

<h3>the naive way</h3>

<p>Just save method result to a instance variable, this can be achieved by wrapping old model method, as following:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># BEFORE</span>
</span><span class='line'><span class="k">def</span> <span class="nf">expensive_method</span>
</span><span class='line'>  <span class="nb">sleep</span> <span class="mi">30</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># AFTER</span>
</span><span class='line'><span class="k">def</span> <span class="nf">expensive_method</span>
</span><span class='line'>  <span class="vi">@expensive_method_result</span> <span class="o">||=</span> <span class="n">_expensive_method</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">_expensive_method</span>
</span><span class='line'>  <span class="nb">sleep</span> <span class="mi">30</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>It works and observably improved total time. But there&#8217;s some disadvantages:
- when _expensive_method returns false, the optimization is totally useless
- it invade the original codes, make it harder to read, and will potentially break the specs, this can be a big problem to a large project</p>

<h3>a improved way</h3>

<p>Assume we can write like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># define methods need to cache in class</span>
</span><span class='line'><span class="n">acts_as_method_cacheable</span> <span class="ss">:methods</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="ss">:expensive_method</span><span class="p">,</span> <span class="ss">:another_expensive_method</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In this way we achieved two goals:
- we can handle the case when result is false without writing if/else everywhere
- it&#8217;s less intrusive, even we can rewrite &#8216;reload&#8217; method to clear the cache, so it&#8217;s easy to handle cached method in specs</p>

<h3>ultimate way</h3>

<p>If a method is called for a feature only, do we need to cache it for other cases?
Yes, No. We need a way that can do cache on demand, like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="vi">@post</span><span class="o">.</span><span class="n">cache_method</span><span class="p">(</span><span class="ss">:expensive_method</span><span class="p">)</span>
</span><span class='line'><span class="mi">10</span><span class="o">.</span><span class="n">times</span> <span class="p">{</span> <span class="vi">@post</span><span class="o">.</span><span class="n">expensive_method</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Got it. You can cache on a instance instead in class level.
And where should we write the codes to do cache_method? The answer can be chosen from Model, View, Controller.
The answer is Controller:
- only in controller you knowing exactly which model methods will be called
- and in controller the impact is partial, anything you&#8217;re doing with cache won&#8217;t break other actions, and specs</p>

<h3>do we have helper methods mentioned above as a gem?</h3>

<p>Yes, we do. <a href="https://github.com/bencao/acts_as_method_cacheable">Go there</a> to learn more.</p>

<h2>Improve algorithm</h2>

<p>If you&#8217;ve tried the above ways and the performance is still not reasonable, you can consider to rewrite some key component in a higher efficient algorithm.
Take copy a active record with its association as an example.
We have a grade with many teachers, we need to copy this grade, and its teachers, having the same relationships between grade and teachers.</p>

<h3>traditional way</h3>

<p>Let&#8217;s first do this in a traditional way.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">copied_grade</span> <span class="o">=</span> <span class="vi">@grade</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">save!</span>
</span><span class='line'><span class="vi">@grade</span><span class="o">.</span><span class="n">teachers</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">teacher</span><span class="o">|</span>
</span><span class='line'>  <span class="n">copied_teacher</span> <span class="o">=</span> <span class="n">teacher</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">save!</span>
</span><span class='line'>  <span class="n">copied_grade</span><span class="o">.</span><span class="n">teachers</span> <span class="o">&lt;&lt;</span> <span class="n">copied_teacher</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Any problem to this piece of code? From logic it&#8217;s perfectly true.
But let&#8217;s switch to DB perspective:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># INSERT INTO `grade` (name) VALUES (&quot;grade&quot;)</span>
</span><span class='line'><span class="c1"># INSERT INTO `teacher` (name) VALUES (&quot;teacher&quot;)</span>
</span><span class='line'><span class="c1"># INSERT INTO `grade_teacher_assignment` (grade_id, teacher_id) VALUES (10, 13)</span>
</span><span class='line'><span class="c1"># INSERT INTO `teacher` (name) VALUES (&quot;teacher&quot;)</span>
</span><span class='line'><span class="c1"># INSERT INTO `grade_teacher_assignment` (grade_id, teacher_id) VALUES (10, 13)</span>
</span><span class='line'><span class="c1"># ...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Yes, it results in too many inserts. Is it possible to insert all teachers in one &#8216;INSERT&#8217; statement?
Seems some foundamental changes are needed.</p>

<h3>alternative way</h3>

<p><a href="https://github.com/bencao/acts_as_brand_new_copy">Go there</a> you can see an alternative way of doing copy.</p>

<p>Not only efficiency is improved, code also became cleaner.
So remember, when time comes, write you own algorithm to save the world!</p>

<h2>Improve GC</h2>

<p>Gabage colletor for ruby(MRI) works in a &#8216;Stop the world, Mark-Sweep&#8217; way.
That means, all ruby code will stop being executed and all CPU resources are used to find out gabage objects and free the memory.
To reduce GC time, we can work from two directions:
- see how we can generate less objects in app
- see how we can adjust GC make it run faster</p>

<h3>generate less objects in app</h3>

<p>When you write &#8216;@grade.teachers&#8217; you&#8217;re creating dozens of &#8216;Teacher&#8217; and &#8216;GradeTeacherAssignment&#8217; active record objects.
Say if we need teacher ids only we can write &#8216;@grade.grade_teacher_assignments.map(&amp;:teacher_id)&#8217;, this save us from constructing and GCing &#8216;Teacher&#8217; objects.</p>

<p>Another one is the above copy sample. Brand new copy create only a half active record objects comparing to naive one, it uses hash instead.
So we can always try to find rooms for cutting unnecessary object constructions.</p>

<h3>adjust GC make it run faster</h3>

<p>Digging into <a href="https://github.com/ruby/ruby/blob/trunk/gc.c">ruby GC implementation</a> you will find that there&#8217;re several tunable params to control its behaviours.
For example, I used these settings in my local machine which accelerates visiting speed about 50%</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">export </span><span class="nv">RUBY_HEAP_MIN_SLOTS</span><span class="o">=</span>300000
</span><span class='line'><span class="nb">export </span><span class="nv">RUBY_HEAP_SLOTS_INCREMENT</span><span class="o">=</span>100000
</span><span class='line'><span class="nb">export </span><span class="nv">RUBY_HEAP_SLOTS_GROWTH_FACTOR</span><span class="o">=</span>1
</span><span class='line'><span class="nb">export </span><span class="nv">RUBY_HEAP_FREE_MIN</span><span class="o">=</span>100000
</span><span class='line'><span class="nb">export </span><span class="nv">RUBY_GC_MALLOC_LIMIT</span><span class="o">=</span>30000000
</span></code></pre></td></tr></table></div></figure>


<p>Many articles could be found in internet, for example <a href="http://blog.newrelic.com/2012/10/23/eating-the-1-9-elephant/">Eating the 1.9 elephant</a>.</p>

<h2>Upgrade to latest ruby version</h2>

<p>Ruby is always improving. Later version has many improvements that can speed up your program, such as GC redesign.
Just keep ruby version up to date you could benifit from the effort of whole community.</p>

<h2>Conclusion</h2>

<p>I hope the above tips helps you improve your rails apps&#8217; performance.
Beside of technics, the more important thing is
- the need for speed
- keep an open eye on latest community progress, for example trending repos on github</p>

<p>Thank you for reading!</p>
</div>

</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
	
	
	<a class="addthis_button_tweet"></a>
	
	
	<a class="addthis_counter addthis_pill_style"></a>
	</div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>



<section id="comment">
    <h1 class="title">Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2013 - Ben Cao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'bencao-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://blog.bencao.it/blog/2013/11/03/speed-up-rails-app/';
        var disqus_url = 'http://blog.bencao.it/blog/2013/11/03/speed-up-rails-app/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






		</div>
	</div>
</body>
</html>
